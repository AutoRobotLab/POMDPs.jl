<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generative (PO)MDP Interface · POMDPs.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="POMDPs.jl logo"/></a><h1>POMDPs.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../">POMDPs.jl</a></li><li><a class="toctext" href="../install/">Installation</a></li><li><a class="toctext" href="../get_started/">Getting Started</a></li><li><a class="toctext" href="../concepts/">Concepts and Architecture</a></li></ul></li><li><span class="toctext">Defining (PO)MDP Models</span><ul><li><a class="toctext" href="../def_pomdp/">Defining POMDPs and MDPs</a></li><li><a class="toctext" href="../ddns/">Dynamic Decision Networks</a></li><li><a class="toctext" href="../basic_properties/">Defining Basic (PO)MDP Properties</a></li><li><a class="toctext" href="../explicit/">Explicit (PO)MDP Interface</a></li><li class="current"><a class="toctext" href>Generative (PO)MDP Interface</a><ul class="internal"><li><a class="toctext" href="#Quick-Start-1">Quick Start</a></li><li><a class="toctext" href="#Interface-Description-1">Interface Description</a></li><li><a class="toctext" href="#The-[gen](@ref)-function-1">The <code>gen</code> function</a></li><li><a class="toctext" href="#Examples-1">Examples</a></li><li><a class="toctext" href="#Random-number-generators-1">Random number generators</a></li><li><a class="toctext" href="#Performance-considerations-1">Performance considerations</a></li></ul></li><li><a class="toctext" href="../interfaces/">Spaces and Distributions</a></li><li><a class="toctext" href="../requirements/">Interface Requirements for Problems</a></li></ul></li><li><span class="toctext">Writing Solvers and Updaters</span><ul><li><a class="toctext" href="../def_solver/">Defining a Solver</a></li><li><a class="toctext" href="../specifying_requirements/">Specifying Requirements</a></li><li><a class="toctext" href="../def_updater/">Defining a Belief Updater</a></li></ul></li><li><span class="toctext">Analyzing Results</span><ul><li><a class="toctext" href="../simulation/">Simulation Standard</a></li><li><a class="toctext" href="../run_simulation/">Running Simulations</a></li><li><a class="toctext" href="../policy_interaction/">Interacting with Policies</a></li></ul></li><li><a class="toctext" href="../faq/">Frequently Asked Questions (FAQ)</a></li><li><a class="toctext" href="../api/">API Documentation</a></li></ul></nav><article id="docs"><header><nav><ul><li>Defining (PO)MDP Models</li><li><a href>Generative (PO)MDP Interface</a></li></ul><a class="edit-page" href="https://github.com/JuliaPOMDP/POMDPs.jl/blob/master/docs/src/generative.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Generative (PO)MDP Interface</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="generative_doc-1" href="#generative_doc-1">Generative (PO)MDP Interface</a></h1><h2><a class="nav-anchor" id="Quick-Start-1" href="#Quick-Start-1">Quick Start</a></h2><p>A generative model for most (PO)MDPs can be completely defined with one function:</p><pre><code class="language-julia">function POMDPs.gen(m::YourPOMDPType, s, a, rng)
    # do dynamics/transition calculations here
    return (sp= #=new state=#, r= #=reward=#, o= #=observation=#)
end</code></pre><p>(<code>o</code> is not needed for MDPs.)</p><h2><a class="nav-anchor" id="Interface-Description-1" href="#Interface-Description-1">Interface Description</a></h2><p>The <em>generative</em> interface consists of two functions:</p><ul><li><a href="../api/#POMDPs.gen"><code>gen</code></a> returns samples (e.g. states, observations and rewards) from a generative POMDP model.</li><li><a href="../api/#POMDPs.initialstate"><code>initialstate</code></a> returns a sampled initial state.</li></ul><p>The generative interface is typically used when it is easier to return sampled states and observations rather than explicit distributions as in the <a href="../explicit/#explicit_doc-1">Explicit interface</a>. This type of model is often referred to as a &quot;black-box&quot; model.</p><h2><a class="nav-anchor" id="The-[gen](@ref)-function-1" href="#The-[gen](@ref)-function-1">The <a href="../api/#POMDPs.gen"><code>gen</code></a> function</a></h2><p>The <a href="../api/#POMDPs.gen"><code>gen</code></a> function has three versions differentiated by the type of the first argument.</p><ul><li><p><code>gen(m::Union{POMDP, MDP}, s, a, rng)</code> provides a way to implement a generative model for an entire (PO)MDP in a single function. It should return values for a subset of <a href="../api/#Dynamic-decision-networks-1">the DDN Nodes</a> as a <code>NamedTuple</code>.</p><ul><li>This is typically the quickest and easiest way to implement a new POMDP model or wrap an existing simulator.</li><li>Example (defined by a problem writer): <code>gen(m::MyPOMDP, s, a, rng) = (sp=s+a, r=s^2, o=s+a+randn(rng))</code></li><li>This version should <strong>never</strong> be called by a solver or simulator, since there is no guarantee of which values will be present in the returned object.</li><li>Values for DDN nodes not present in the returned <code>NamedTuple</code> will be generated in the normal way with <code>gen(::DDNNode, ...)</code> or an explicit representation.</li></ul></li><li><p><code>gen(::</code><a href="../api/#POMDPs.DDNNode"><code>DDNNode</code></a><code>{nodename}, m, parent_values..., rng)</code> defines the generative model for a <strong>single <a href="../api/#Dynamic-decision-networks-1">DDN node</a></strong>. Together, a group of these functions can define a problem.</p><ul><li>Example (defined by a problem writer): <code>gen(::DDNNode{:o}, m::MyPOMDP, s, a, sp, rng) = sp + randn(rng)</code></li><li>Solver writers should only directly call this version in very rare cases when it needs to access to values for a particular node of the DDN generated by specific values of its parent nodes.</li></ul></li><li><p><code>gen(::</code><a href="../api/#POMDPs.DDNOut"><code>DDNOut</code></a><code>{nodenames}, m, s, a, rng)</code> returns a value or tuple of values for a subset of nodes in the <a href="../api/#Dynamic-decision-networks-1">DDN</a>. The arguments are values for the <strong>input nodes</strong> (currently <code>:s</code> and <code>:a</code>), treating the entire DDN as a single black box.</p><ul><li>This is the version that solvers and simulators should call.</li><li>Example (called in a solver): <code>sp, o, r = gen(DDNOut(:sp,:o,:r), m, s, a, rng)</code></li><li>This function is automatically synthesized by POMDPs.jl by combining <code>gen(m, s, a, rng)</code> and <code>gen(::DDNNode, ...)</code> or <a href="../explicit/#explicit_doc-1">explicit model definitions</a> for all <a href="../api/#Dynamic-decision-networks-1">DDN nodes</a>.</li><li>This version should only be implemented directly by problem writers in very rare cases when they need precise control for efficiency.</li></ul></li></ul><p>In all versions, <code>m</code> is a (PO)MDP model, and <code>rng</code> is a <a href="#Random-number-generators-1">random number generator</a>.</p><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><p>An example of defining a problem with the generative interface can be found <a href="https://github.com/JuliaPOMDP/POMDPExamples.jl/blob/master/notebooks/Defining-a-POMDP-with-the-Generative-Interface.ipynb">in the POMDPExamples package</a>.</p><h2><a class="nav-anchor" id="Random-number-generators-1" href="#Random-number-generators-1">Random number generators</a></h2><p>The <code>rng</code> argument to functions in the generative interface is a random number generator such as <code>Random.GLOBAL_RNG</code> or another <code>MersenneTwister</code>. It should be used to generate all random numbers within the function (e.g. use <code>rand(rng)</code> instead of <code>rand()</code>). This will ensure that all simulations are exactly repeatable. See the <a href="https://docs.julialang.org/en/v1/stdlib/Random/#Random-Numbers-1">Julia documentation on random numbers</a> for more information about these objects.</p><h2><a class="nav-anchor" id="Performance-considerations-1" href="#Performance-considerations-1">Performance considerations</a></h2><p>In general, calling <code>gen(::DDNOut, ...)</code> when <code>gen(::POMDP, ...)</code> is implemented does not introduce much overhead. In fact, in some cases, the compiler will even optimize out calculations of extra genvars. For example:</p><pre><code class="language-julia">struct M &lt;: MDP{Int, Int} end

POMDPs.gen(::M, s, a, rng) = (sp=s+a, r=s^2)

@code_warntype gen(DDNOut(:sp), M(), 1, 1, Random.GLOBAL_RNG)</code></pre><p>will yield</p><pre><code class="language-none">Body::Int64
1 ─ %1 = (Base.add_int)(s, a)::Int64
│        nothing
└──      return %1</code></pre><p>indicating that the compiler will only perform the addition to find the next state and skip the <code>s^2</code> calculation for the reward.</p><p>Unfortunately, if random numbers are used in <code>gen</code>, the compiler will not be able to optimize out the change in the rng&#39;s state, so it may be beneficial to directly implement versions of <code>gen(::DDNNode, ...)</code>. For example</p><pre><code class="language-julia">POMDPs.gen(::DDNNode{:sp}, ::M, s, a, rng) = s+a
POMDPs.reward(::M, s, a) = abs(s)
PODMPs.gen(::DDNNode{:o}, ::M, s, a, sp, rng) = sp+randn(rng)</code></pre><p>might be more efficient than</p><pre><code class="language-julia">function POMDPs.gen(::M, s, a, rng)
    sp = s + a
    return (sp=sp, r=abs(s), o=sp+randn(rng))
end</code></pre><p>in the context of particle filtering.</p><p>As always, though, one should resist the urge towards premature optimization; careful profiling to see what is actually slow is much more effective than speculation.</p><footer><hr/><a class="previous" href="../explicit/"><span class="direction">Previous</span><span class="title">Explicit (PO)MDP Interface</span></a><a class="next" href="../interfaces/"><span class="direction">Next</span><span class="title">Spaces and Distributions</span></a></footer></article></body></html>
