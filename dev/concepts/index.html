<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Concepts and Architecture · POMDPs.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="POMDPs.jl logo"/></a><h1>POMDPs.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../">POMDPs.jl</a></li><li><a class="toctext" href="../install/">Installation</a></li><li><a class="toctext" href="../get_started/">Getting Started</a></li><li class="current"><a class="toctext" href>Concepts and Architecture</a><ul class="internal"><li><a class="toctext" href="#POMDPs-and-MDPs-1">POMDPs and MDPs</a></li><li><a class="toctext" href="#Beliefs-and-Updaters-1">Beliefs and Updaters</a></li><li><a class="toctext" href="#Solvers-and-Policies-1">Solvers and Policies</a></li><li><a class="toctext" href="#Simulators-1">Simulators</a></li></ul></li></ul></li><li><span class="toctext">Defining (PO)MDP Models</span><ul><li><a class="toctext" href="../def_pomdp/">Defining POMDPs and MDPs</a></li><li><a class="toctext" href="../explicit/">Explicit (PO)MDP Interface</a></li><li><a class="toctext" href="../generative/">Generative (PO)MDP Interface</a></li><li><a class="toctext" href="../requirements/">Interface Requirements for Problems</a></li><li><a class="toctext" href="../interfaces/">Spaces and Distributions</a></li></ul></li><li><span class="toctext">Writing Solvers and Updaters</span><ul><li><a class="toctext" href="../def_solver/">Defining a Solver</a></li><li><a class="toctext" href="../specifying_requirements/">Specifying Requirements</a></li><li><a class="toctext" href="../def_updater/">Defining a Belief Updater</a></li></ul></li><li><span class="toctext">Analyzing Results</span><ul><li><a class="toctext" href="../simulation/">Simulation Standard</a></li><li><a class="toctext" href="../run_simulation/">Running Simulations</a></li><li><a class="toctext" href="../policy_interaction/">Interacting with Policies</a></li></ul></li><li><a class="toctext" href="../faq/">Frequently Asked Questions (FAQ)</a></li><li><a class="toctext" href="../api/">API Documentation</a></li></ul></nav><article id="docs"><header><nav><ul><li>Basics</li><li><a href>Concepts and Architecture</a></li></ul><a class="edit-page" href="https://github.com/JuliaPOMDP/POMDPs.jl/blob/master/docs/src/concepts.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Concepts and Architecture</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Concepts-and-Architecture-1" href="#Concepts-and-Architecture-1">Concepts and Architecture</a></h1><p>POMDPs.jl aims to coordinate the development of three software components: 1) a problem, 2) a solver, 3) an experiment. Each of these components has a set of abstract types associated with it and a set of functions that allow a user to define each component&#39;s behavior in a standardized way. An outline of the architecture is shown below.</p><p><img src="../figures/concepts.png" alt="concepts"/></p><p>The MDP and POMDP types are associated with the problem definition. The Solver and Policy types are associated with the solver or decision-making agent. Typically, the Updater type is also associated with the solver, but a solver may sometimes be used with an updater that was implemented separately. The Simulator type is associated with the experiment.</p><p>The code components of the POMDPs.jl ecosystem relevant to problems and solvers are shown below. The arrows represent the flow of information from the problems to the solvers. The figure shows the two interfaces that form POMDPs.jl - Explicit and Generative. Details about these interfaces can be found in the section on <a href="../def_pomdp/#defining_pomdps-1">Defining POMDPs</a>.</p><p><img src="../figures/interface_relationships.svg" alt="interface_relationships"/></p><h2><a class="nav-anchor" id="POMDPs-and-MDPs-1" href="#POMDPs-and-MDPs-1">POMDPs and MDPs</a></h2><p>An MDP is a mathematical framework for sequential decision making under uncertainty, and where all of the uncertainty arrises from outcomes that are partially random and partially under the control of a decision maker. Mathematically, an MDP is a tuple (S,A,T,R), where S is the state space, A is the action space, T is a transition function defining the probability of transitioning to each state given the state and action at the previous time, and R is a reward function mapping every possible transition (s,a,s&#39;) to a real reward value. For more information see a textbook such as [1]. In POMDPs.jl an MDP is represented by a concrete subtype of the <a href="../api/#POMDPs.MDP"><code>MDP</code></a> abstract type and a set of methods that define each of its components. S and A are defined by implementing <a href="../api/#POMDPs.states"><code>states</code></a> and <a href="../api/#POMDPs.actions"><code>actions</code></a> for your specific <a href="../api/#POMDPs.MDP"><code>MDP</code></a> subtype. R is by implementing <a href="../api/#POMDPs.reward"><code>reward</code></a>, and T is defined by implementing <a href="../api/#POMDPs.transition"><code>transition</code></a> if the <a href="../def_pomdp/#defining_pomdps-1"><em>explicit</em></a> interface is used or <a href="../api/#POMDPs.generate_s"><code>generate_s</code></a> if the <a href="../def_pomdp/#defining_pomdps-1"><em>generative</em></a> interface is used.</p><p>A POMDP is a more general sequential decision making problem in which the agent is not sure what state they are in. The state is only partially observable by the decision making agent. Mathematically, a POMDP is a tuple (S,A,T,R,O,Z) where S, A, T, and R are the same as with MDPs, Z is the agent&#39;s observation space, and O defines the probability of receiving each observation at a transition. In POMDPs.jl, a POMDP is represented by a concrete subtype of the <a href="../api/#POMDPs.POMDP"><code>POMDP</code></a> abstract type, <code>Z</code> may be defined by the <a href="../api/#POMDPs.observations"><code>observations</code></a> function (though an explicit definition is often not required), and <code>O</code> is defined by implementing <a href="../api/#POMDPs.observation"><code>observation</code></a> if the <a href="../def_pomdp/#defining_pomdps-1"><em>explicit</em></a> interface is used or <a href="../api/#POMDPs.generate_o"><code>generate_o</code></a> if the <a href="../def_pomdp/#defining_pomdps-1"><em>generative</em></a> interface is used.</p><p>POMDPs.jl also contains functions for defining optional problem behavior such as a <a href="@ref discount">discount factor</a> or a set of <a href="@ref isterminal">terminal states</a>.</p><p>More information can be found in the <a href="../def_pomdp/#defining_pomdps-1">Defining POMDPs</a> section.</p><h2><a class="nav-anchor" id="Beliefs-and-Updaters-1" href="#Beliefs-and-Updaters-1">Beliefs and Updaters</a></h2><p>In a POMDP domain, the decision-making agent does not have complete information about the state of the problem, so the agent can only make choices based on its &quot;belief&quot; about the state. In the POMDP literature, the term &quot;belief&quot; is typically defined to mean a probability distribution over all possible states of the system. However, in practice, the agent often makes decisions based on an incomplete or lossy record of past observations that has a structure much different from a probability distribution. For example, if the agent is represented by a finite-state controller, as is the case for Monte-Carlo Value Iteration [2], the belief is the controller state, which is a node in a graph. Another example is an agent represented by a recurrent neural network. In this case, the agent&#39;s belief is the state of the network. In order to accommodate a wide variety of decision-making approaches in POMDPs.jl, we use the term &quot;belief&quot; to denote the set of information that the agent makes a decision on, which could be an exact state distribution, an action-observation history, a set of weighted particles, or the examples mentioned before. In code, the belief can be represented by any built-in or user-defined type.</p><p>When an action is taken and a new observation is received, the belief is updated by the belief updater. In code, a belief updater is represented by a concrete subtype of the <a href="../api/#POMDPs.Updater"><code>Updater</code></a> abstract type, and the <a href="../api/#POMDPs.update"><code>update(updater, belief, action, observation)</code></a> function defines how the belief is updated when a new observation is received.</p><p>Although the agent may use a specialized belief structure to make decisions, the information initially given to the agent about the state of the problem is usually most conveniently represented as a state distribution, thus the <a href="../api/#POMDPs.initialize_belief"><code>initialize_belief</code></a> function is provided to convert a state distribution to a specialized belief structure that an updater can work with.</p><p>In many cases, the belief structure is closely related to the solution technique, so it will be implemented by the programmer who writes the solver. In other cases, the agent can use a variety of belief structures to make decisions, so a domain-specific updater implemented by the programmer that wrote the problem description may be appropriate. Finally, some advanced generic belief updaters such as particle filters may be implemented by a third party. The convenience function <a href="../api/#POMDPs.updater"><code>updater(policy)</code></a> can be used to get a suitable default updater for a policy, however many policies can work with other updaters.</p><p>For more information on implementing a belief updater, see <a href="../def_updater/#Defining-a-Belief-Updater-1">Defining a Belief Updater</a></p><h2><a class="nav-anchor" id="Solvers-and-Policies-1" href="#Solvers-and-Policies-1">Solvers and Policies</a></h2><p>Sequential decision making under uncertainty involves both online and offline calculations. In the broad sense, the term &quot;solver&quot; as used in the node in the figure at the top of the page refers to the software package that performs the calculations at both of these times. However, the code is broken up into two pieces, the solver that performs calculations offline and the policy that performs calculations online.</p><p>In the abstract, a policy is a mapping from every belief that an agent might take to an action. A policy is represented in code by a concrete subtype of the <a href="../api/#POMDPs.Policy"><code>Policy</code></a> abstract type. The programmer implements <a href="../api/#POMDPs.action"><code>action</code></a> to describe what computations need to be done online. For an online solver such as POMCP, all of the decision computation occurs within <a href="../api/#POMDPs.action"><code>action</code></a> while for an offline solver like SARSOP, there is very little computation within <a href="../api/#POMDPs.action"><code>action</code></a>. See <a href="../policy_interaction/#Interacting-with-Policies-1">Interacting with Policies</a> for more information.</p><p>The offline portion of the computation is carried out by the solver, which is represented by a concrete subtype of the <a href="../api/#POMDPs.Solver"><code>Solver</code></a> abstract type. Computations occur within the <a href="../api/#POMDPs.solve"><code>solve</code></a> function. For an offline solver like SARSOP, nearly all of the decision computation occurs within this function, but for some online solvers such as POMCP, <a href="../api/#POMDPs.solve"><code>solve</code></a> merely embeds the problem in the policy.</p><h2><a class="nav-anchor" id="Simulators-1" href="#Simulators-1">Simulators</a></h2><p>A simulator defines a way to run one or more simulations. It is represented by a concrete subtype of the <a href="../api/#POMDPs.Simulator"><code>Simulator</code></a> abstract type and the simulation is an implemention of <a href="../api/#POMDPs.simulate"><code>simulate</code></a>. Depending on the simulator, <a href="../api/#POMDPs.simulate"><code>simulate</code></a> may return a variety of data about the simulation, such as the discounted reward or the state history. All simulators should perform simulations consistent with the <a href="../simulation/#Simulation-Standard-1">Simulation Standard</a>.</p><p>[1] <em>Decision Making Under Uncertainty: Theory and Application</em> by Mykel J. Kochenderfer, MIT Press, 2015</p><p>[2] Bai, H., Hsu, D., &amp; Lee, W. S. (2014). Integrated perception and planning in the continuous space: A POMDP approach. The International Journal of Robotics Research, 33(9), 1288-1302</p><footer><hr/><a class="previous" href="../get_started/"><span class="direction">Previous</span><span class="title">Getting Started</span></a><a class="next" href="../def_pomdp/"><span class="direction">Next</span><span class="title">Defining POMDPs and MDPs</span></a></footer></article></body></html>
