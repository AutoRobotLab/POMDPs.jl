


function gen end
function genstate end
function genobs end


@generated function generate(v::Val{t::Tuple}, m, s, a, rng)
    @debug("Creating an implementation for gen(::Val{$S}, ::M, ::S, ::A, ::RNG)", M=m, S=s, A=a, RNG=rng)
    # look for gen
    # if gen exists
    #   use it. At runtime, if missing S, try to get it, and if you can't, warn that it is not in the return of gen
    if implemented(gen, Tuple{m, s, a, rng})
        @debug("Found gen(::M, ::S, ::A, ::RNG)", M=m, S=s, A=a, RNG=rng)

        expr = quote
            x = gen(m, s, a, rng)
        end
        return_tuple_elements = Expr[]
        @assert expr.head = :block
        for var::Symbol in v.parameters
            sym = Meta.quot(var)
            genvarargs = genvars[var].deps
            varblock = quote
                if haskey(x, $sym)
                    $var = x[$sym]
                else
                    $var = generate_default(sym, m, $(genvarargs...), rng)
                end
            end
            append!(expr.args, varblock.args)
            push!(return_tuple_elements, :($var=$var))
        end
        return_expr = :(return ($(return_tuple_elements...)))
        append!(expr.args, return_expr.args)

    # elseif generate_ is implemented **directly**
    #   warn
    #   use it
    elseif implemented(old_generate_function(v), Tuple{m, s, a, rng})
        # TODO
        @warn("")
        expr = :($(old_generate_function(v))(m, s, a, rng))

    # elseif explicit is implemented
    #   construct from explicit
    else
        # TODO
        error("Not implemented yet.")
    end
    @debug("Implementing generate(::Val{$S}, ::M, ::S, ::A, ::RNG) with:\n$expr")
    return expr
end

struct GenVarData
    mod::Module #?
    longname::String
    descripton::String
    deps::Array{Symbol}
end

const genvars = Dict{Symbol, GenVarData}()
genvars[:s] = GenVarData(@__Module__, "state", "state at the beginning of the step", Symbol[])
genvars[:a] = GenVarData(@__Module__, "action", "action taken by the agent", Symbol[])
genvars[:sp] = GenVarData(@__Module__, "new state", "state at the end of the step", [:s, :a])
genvars[:o] = GenVarData(@__Module__, "observation", "observation (usually depends on sp)", [:s, :a, :sp])
genvars[:r] = GenVarData(@__Module__, "reward", "reward generated by the step", [:s, :a, :sp, :o])

@generated function generate_default(::Val{:sp}, m, s, a, rng)
    if implemented(genstate, Tuple{m,s,a,rng})
        expr = :(genstate(m, s, a, rng))
    elseif implemented(transition, Tuple{m,s,a})
        expr = :(rand(rng, transition(m, s, a)))
    elseif implemented(generate_s, Tuple{m,s,a,rng}) 
        # TODO warn
        expr = :(generate_s(m, s, a, rng))
    else
        expr = quote
            try
                genstate
                throw_absent_genvar(:sp, [Req(genstate, Tuple{m,s,a,rng}), Req(transition, Tuple{m,s,a})])
        end
    end
    @debug("Fallback expression for `sp` is:\n$expr")
    return expr
end

@generated function generate_default(::Val{:o}, m, s, a, sp, rng)
    if implemented(genobs, Tuple{m,s,a,sp,rng})
        expr = :(genobs(m, s, a, sp, rng))
    elseif implemented(observation, Tuple{m,s,a,sp})
        expr = :(rand(rng, observation(m, s, a, sp)))
    elseif implemented(generate_o, Tuple{

    else
        expr = quote
            try
                genobs(m,s,a,sp,rng) # for backedges; should throw a MethodError
                observation(m,s,a,sp)
            catch
                throw_absent_genvar(:o, [Req(genobs, Tuple{m,s,a,sp,rng}),
                                         Req(observation, Tuple{m,s,a,sp})])
            end
        end
    end
    @debug("Fallback expression for `o` is:\n$expr")
    return expr
end

@generated function generate_default(::Val{:r}, m, s, a, sp, o, rng) = reward(m, nt.s, nt.a, nt.sp, nt.o)
    if implemented(reward, Tuple{m,s,a,sp,o})
        expr = :(reward(m, s, a, sp, o))
    else
        expr = quote
            try
                return reward(m, s, a, sp, o) # for backedges; should throw a MethodError
            catch
                throw_absent_genvar(:r, [Req(reward, Tuple{m,s,a,sp,o})])
            end
        end
    end
    @debug("Fallback expression for `r` is:\n$expr")
    return expr
end

function throw_absent_genvar(sym::Symbol, suggestions::AbstractVector{Req})
    
end
